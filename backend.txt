backend/*** app/*   *** __init__.py*   *** models.py*   *** routes/*   *   *** __init__.py*   *   *** auth.py*   *   *** tasks.py*   *   *** preferences.py*   *** utils.py*   *** config.py*** tests/*   *** test_app.py*** requirements.txt*** run.pyrequirements.txt:CopyFlask==2.0.1Flask-SQLAlchemy==2.5.1Flask-Migrate==3.1.0Flask-JWT-Extended==4.3.1Flask-CORS==3.0.10pytest==6.2.5app/init.py:pythonCopyfrom flask import Flaskfrom flask_sqlalchemy import SQLAlchemyfrom flask_jwt_extended import JWTManagerfrom flask_cors import CORSfrom .config import Configdb = SQLAlchemy()jwt = JWTManager()def create_app():    app = Flask(__name__)    app.config.from_object(Config)    db.init_app(app)    jwt.init_app(app)    CORS(app)    from .routes import auth, tasks, preferences    app.register_blueprint(auth.bp)    app.register_blueprint(tasks.bp)    app.register_blueprint(preferences.bp)    return appapp/config.py:pythonCopyimport osclass Config:    SECRET_KEY = os.environ.get('SECRET_KEY') or 'your-secret-key'    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or 'sqlite:///app.db'    SQLALCHEMY_TRACK_MODIFICATIONS = False    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY') or 'jwt-secret-key'app/models.py:pythonCopyfrom . import dbfrom werkzeug.security import generate_password_hash, check_password_hashclass User(db.Model):    id = db.Column(db.Integer, primary_key=True)    username = db.Column(db.String(64), unique=True, nullable=False)    password_hash = db.Column(db.String(128))    tasks = db.relationship('Task', backref='user', lazy='dynamic')    preferences = db.relationship('Preference', backref='user', lazy='dynamic')    def set_password(self, password):        self.password_hash = generate_password_hash(password)    def check_password(self, password):        return check_password_hash(self.password_hash, password)class Task(db.Model):    id = db.Column(db.Integer, primary_key=True)    description = db.Column(db.String(200), nullable=False)    completed = db.Column(db.Boolean, default=False)    created_at = db.Column(db.DateTime, default=db.func.current_timestamp())    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)class Preference(db.Model):    id = db.Column(db.Integer, primary_key=True)    key = db.Column(db.String(64), nullable=False)    value = db.Column(db.String(200))    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)app/routes/auth.py:pythonCopyfrom flask import Blueprint, request, jsonifyfrom flask_jwt_extended import create_access_tokenfrom ..models import Userfrom .. import dbbp = Blueprint('auth', __name__, url_prefix='/auth')@bp.route('/register', methods=['POST'])def register():    data = request.get_json()    if User.query.filter_by(username=data['username']).first():        return jsonify({"msg": "Username already exists"}), 400    user = User(username=data['username'])    user.set_password(data['password'])    db.session.add(user)    db.session.commit()    return jsonify({"msg": "User created successfully"}), 201@bp.route('/login', methods=['POST'])def login():    data = request.get_json()    user = User.query.filter_by(username=data['username']).first()    if user and user.check_password(data['password']):        access_token = create_access_token(identity=user.id)        return jsonify(access_token=access_token), 200    return jsonify({"msg": "Invalid username or password"}), 401app/routes/tasks.py:pythonCopyfrom flask import Blueprint, request, jsonifyfrom flask_jwt_extended import jwt_required, get_jwt_identityfrom ..models import Taskfrom .. import dbbp = Blueprint('tasks', __name__, url_prefix='/tasks')@bp.route('', methods=['GET'])@jwt_required()def get_tasks():    user_id = get_jwt_identity()    tasks = Task.query.filter_by(user_id=user_id).all()    return jsonify([{        'id': task.id,        'description': task.description,        'completed': task.completed,        'created_at': task.created_at    } for task in tasks]), 200@bp.route('', methods=['POST'])@jwt_required()def create_task():    user_id = get_jwt_identity()    data = request.get_json()    task = Task(description=data['description'], user_id=user_id)    db.session.add(task)    db.session.commit()    return jsonify({        'id': task.id,        'description': task.description,        'completed': task.completed,        'created_at': task.created_at    }), 201@bp.route('/<int:task_id>', methods=['PUT'])@jwt_required()def update_task(task_id):    user_id = get_jwt_identity()    task = Task.query.filter_by(id=task_id, user_id=user_id).first()    if not task:        return jsonify({"msg": "Task not found"}), 404    data = request.get_json()    task.description = data.get('description', task.description)    task.completed = data.get('completed', task.completed)    db.session.commit()    return jsonify({        'id': task.id,        'description': task.description,        'completed': task.completed,        'created_at': task.created_at    }), 200@bp.route('/<int:task_id>', methods=['DELETE'])@jwt_required()def delete_task(task_id):    user_id = get_jwt_identity()    task = Task.query.filter_by(id=task_id, user_id=user_id).first()    if not task:        return jsonify({"msg": "Task not found"}), 404    db.session.delete(task)    db.session.commit()    return jsonify({"msg": "Task deleted"}), 200app/routes/preferences.py:pythonCopyfrom flask import Blueprint, request, jsonifyfrom flask_jwt_extended import jwt_required, get_jwt_identityfrom ..models import Preferencefrom .. import dbbp = Blueprint('preferences', __name__, url_prefix='/preferences')@bp.route('', methods=['GET'])@jwt_required()def get_preferences():    user_id = get_jwt_identity()    preferences = Preference.query.filter_by(user_id=user_id).all()    return jsonify({pref.key: pref.value for pref in preferences}), 200@bp.route('', methods=['POST'])@jwt_required()def set_preference():    user_id = get_jwt_identity()    data = request.get_json()    for key, value in data.items():        pref = Preference.query.filter_by(user_id=user_id, key=key).first()        if pref:            pref.value = value        else:            pref = Preference(key=key, value=value, user_id=user_id)            db.session.add(pref)    db.session.commit()    return jsonify({"msg": "Preferences updated"}), 200run.py:pythonCopyfrom app import create_app, dbapp = create_app()if __name__ == '__main__':    with app.app_context():        db.create_all()    app.run(debug=True)2. Frontend (Swift/SwiftUI)Now, let's create an improved frontend using SwiftUI:swiftCopyimport SwiftUIstruct ContentView: View {    @StateObject private var authViewModel = AuthViewModel()    @StateObject private var taskViewModel = TaskViewModel()    @StateObject private var preferenceViewModel = PreferenceViewModel()        var body: some View {        if authViewModel.isAuthenticated {            TabView {                TaskListView()                    .tabItem {                        Label("Tasks", systemImage: "list.bullet")                    }                PreferencesView()                    .tabItem {                        Label("Preferences", systemImage: "gear")                    }            }            .environmentObject(authViewModel)            .environmentObject(taskViewModel)            .environmentObject(preferenceViewModel)        } else {            LoginView()                .environmentObject(authViewModel)        }    }}struct LoginView: View {    @EnvironmentObject var authViewModel: AuthViewModel    @State private var username = ""    @State private var password = ""        var body: some View {        VStack {            TextField("Username", text: $username)                .textFieldStyle(RoundedBorderTextFieldStyle())            SecureField("Password", text: $password)                .textFieldStyle(RoundedBorderTextFieldStyle())            Button("Login") {                authViewModel.login(username: username, password: password)            }            .buttonStyle(.borderedProminent)            if authViewModel.error != nil {                Text(authViewModel.error!)                    .foregroundColor(.red)            }        }        .padding()    }}struct TaskListView: View {    @EnvironmentObject var taskViewModel: TaskViewModel    @State private var newTaskDescription = ""        var body: some View {        NavigationView {            List {                ForEach(taskViewModel.tasks) { task in                    TaskRow(task: task)                }                .onDelete(perform: deleteTask)            }            .navigationTitle("Tasks")            .toolbar {                ToolbarItem(placement: .bottomBar) {                    HStack {                        TextField("New task", text: $newTaskDescription)                        Button("Add") {                            taskViewModel.addTask(description: newTaskDescription)                            newTaskDescription = ""                        }                        .disabled(newTaskDescription.isEmpty)                    }                }            }        }        .onAppear {            taskViewModel.fetchTasks()        }    }        func deleteTask(at offsets: IndexSet) {        offsets.forEach { index in            let task = taskViewModel.tasks[index]            taskViewModel.deleteTask(task)        }    }}struct TaskRow: View {    @EnvironmentObject var taskViewModel: TaskViewModel    let task: Task        var body: some View {        HStack {            Text(task.description)            Spacer()            Button(action: {                taskViewModel.toggleTaskCompletion(task)            }) {                Image(systemName: task.completed * "checkmark.circle.fill" : "circle")            }        }    }}struct PreferencesView: View {    @EnvironmentObject var preferenceViewModel: PreferenceViewModel    @State private var newKey = ""    @State private var newValue = ""        var body: some View {        NavigationView {            Form {                ForEach(preferenceViewModel.preferences.sorted(by: { $0.key < $1.key }), id: \.key) { key, value in                    HStack {                        Text(key)                        Spacer()                        Text(value)                    }                }                Section(header: Text("Add New Preference")) {                    TextField("Key", text: $newKey)                    TextField("Value", text: $newValue)                    Button("Add") {                        preferenceViewModel.setPreference(key: newKey, value: newValue)                        newKey = ""                        newValue = ""                    }                    .disabled(newKey.isEmpty || newValue.isEmpty)                }            }            .navigationTitle("Preferences")        }        .onAppear {            preferenceViewModel.fetchPreferences()        }    }}class AuthViewModel: ObservableObject {    @Published var isAuthenticated = false    @Published var error: String*    private var token: String*        func login(username: String, password: String) {        // Implement API call to login        // On success, set isAuthenticated to true and store the token    }        func logout() {        isAuthenticated = false        token = nil    }}struct Task: Identifiable {    let id: Int    var description: String    var completed: Bool}class TaskViewModel: ObservableObject {    @Published var tasks: [Task] = []        func fetchTasks() {        // Implement API call to fetch tasks    }        func addTask(description: String) {        // Implement API call to add a task    }        func toggleTaskCompletion(_ task: Task) {        // Implement API call to update task completion status    }        func deleteTask(_ task: Task) {        // Implement API call to delete a task    }}class PreferenceViewModel: ObservableObject {    @Published var preferences: [String: String] = [:]        func fetchPreferences() {        // Implement API call to fetch preferences    }        func setPreference(key: String, value: String) {        // Implement API call to set a preference    }}@mainstruct DigitalAgentApp: App {    var body: some Scene {        WindowGroup {            ContentView()        }    }}